(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[902],{6057:function(n,e,o){Promise.resolve().then(o.bind(o,6858))},6858:function(n,e,o){"use strict";o.r(e),o.d(e,{default:function(){return w}});var t=o(7437),i=o(2265),a=o(9671),r=o.n(a);o(8154);var s=o(9473),c=o(3149),l=o(4741),x=o(1196),p=o(4262),u=o(6547),m=o(9791),v=o(8421),d=o(7776),f=o(948),h=o.n(f);function y(n){let{children:e,data:o,range:a,...r}=n,s=(0,i.useRef)(null),c=(0,i.useRef)(null);return(0,t.jsxs)(t.Fragment,{children:[i.cloneElement(e,{ref:c}),(0,t.jsxs)("instancedMesh",{ref:s,args:[void 0,void 0,a],...r,children:[(0,t.jsx)("coneGeometry",{args:[.1,.3,16],rotation:[0,0,-Math.PI/2]}),(0,t.jsx)("meshStandardMaterial",{})]}),(0,t.jsx)(l.Z,{transform:n=>{let{position:e,normal:o,sampledMesh:t,dummy:i}=n,a=e.clone().multiplyScalar(1.1);h().simplex3(...a.toArray());let r=o.clone();return i.position.copy(a).add(t.position),i.lookAt(r.add(e)),i.updateMatrix(),i},mesh:c,instances:s,count:a})]})}let _=(0,i.forwardRef)((n,e)=>{let a=o(1198).Z,r=o(338).Z,c=(0,i.useRef)(),l=(0,i.useMemo)(()=>({u_time:{value:0},u_scale:{value:.5},u_colorB:{value:new d.Color("#FF11aa")},u_colorA:{value:new d.Color("#00aaFF")}}),[]);return(0,s.C)(n=>{let{clock:e}=n,o=e.getElapsedTime();l.u_time.value=.2*o}),(0,t.jsxs)("group",{children:[(0,t.jsxs)("mesh",{ref:e,children:[(0,t.jsx)("sphereGeometry",{args:[2,1024,512],ref:c}),(0,t.jsx)("shaderMaterial",{vertexShader:a,fragmentShader:r,uniforms:l,side:d.DoubleSide})]}),(0,t.jsxs)("mesh",{position:[0,0,0],children:[(0,t.jsx)("sphereGeometry",{args:[1.98,32,16]}),(0,t.jsx)(x.z,{samples:32,resolution:1024,anisotropicBlur:.1,ior:1.3,roughness:.02,thickness:1,toneMapped:!0})]})]})}),g=()=>{let n=n=>[n/2-Math.random()*n,n/2-Math.random()*n,n/2-Math.random()*n],e=()=>[Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI],o=Array.from({length:100},function(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10;return{random:Math.random(),position:n(o),rotation:e()}});return(0,t.jsxs)(c.Xz,{children:[(0,t.jsx)(p.c,{makeDefault:!0,position:[0,5,5]}),(0,t.jsx)(u.z,{}),(0,t.jsx)("ambientLight",{intensity:Math.PI/2}),(0,t.jsx)("spotLight",{position:[10,10,10],angle:.15,penumbra:1,decay:0,intensity:Math.PI}),(0,t.jsx)("pointLight",{position:[-10,-10,-10],decay:0,intensity:Math.PI}),(0,t.jsx)(m.qA,{background:!1,preset:"city",blur:1}),(0,t.jsx)(v.u,{firstHitOnly:!0,children:(0,t.jsx)(y,{data:o,range:100,children:(0,t.jsx)(_,{position:[0,0,0]})})})]})};g.displayName="World";var w=()=>(0,t.jsx)("div",{className:r().main,children:(0,t.jsx)(g,{})})},9671:function(n){n.exports={main:"page_main__GlU4n",center:"page_center__5oHG7",spin:"page_spin__W_8_q",canvas:"page_canvas__dt_l4",marqueeT:"page_marqueeT__fHP76",moveText:"page_moveText__meMx1",marqueeB:"page_marqueeB__dZ3Dl",circle:"page_circle__uHZRA"}},338:function(n,e){"use strict";e.Z="uniform vec3 u_colorA;\nuniform vec3 u_colorB;\nvarying float vZ;\n\n\nvoid main() {\n  vec3 color = mix(u_colorA, u_colorB, vZ * 2.0 + 0.5); \n  gl_FragColor = vec4(color, 1.0);\n}\n"},1198:function(n,e){"use strict";e.Z="uniform float u_time;\nuniform float u_scale;\n\nvarying float vZ;\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n	float f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\n\n//	Simplex 4D Noise \n//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\nvoid main() {\n    vec4 pos = modelMatrix * vec4(position, 1.0);\n  \n//   modelPosition.z += sin(modelPosition.x * 5.0 + u_time * 3.0) * 0.3;\n//   modelPosition.z += sin(modelPosition.y * 6.0 + u_time * 2.0) * 0.3;\n\n    // modelPosition.y = 0.;\n    float n = 0.;\n    float r = length(pos);\n    float theta = atan(pos.y, pos.x);\n    float phi = acos(pos.z / r);\n\n    for(int i = 0; i < 4; i++){\n        float scale = pow(u_scale, float(i));\n        float xx = theta/scale;\n        float yy = phi / scale;\n        vec3 nPos = pos.xyz / r ;\n        nPos *= 2.;\n        // nPos.x += .002;\n        n += 0.3 * scale * snoise(vec4(nPos / scale, u_time));\n    }\n\n    pos.xyz += n * pos.xyz / r;\n  \n    vZ = n;\n    // vZ = phi;\n\n    vec4 viewPosition = viewMatrix * pos;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n\n    gl_Position = projectedPosition;\n}\n"}},function(n){n.O(0,[967,689,961,591,234,971,23,744],function(){return n(n.s=6057)}),_N_E=n.O()}]);